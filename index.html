<!--
Simple COVID-19 charting code, single-page HTML javascript.
-->
<!doctype html>
<html>
<head>
<meta name="description" content="Interactive chart of coronavirus cases over time.">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!--
   Library dependencies, loaded from various CDNs.
 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js" integrity="sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.1.0/papaparse.js" integrity="sha256-iAuxnf8Cwr0yrQkpf6oQG4PaL/oVmoer6V/RfX2KQws=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js" integrity="sha256-VeNaFBVDhoX3H+gJ37DpT/nTuZTdjYro9yBruHjVmoQ=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chartist/0.11.4/chartist.js" integrity="sha256-Nyn8cCQAr3TDltwQENC7vbHQaLKy9xuq8xon2BNZgPk=" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chartist/0.11.4/chartist.min.css" integrity="sha256-seGyqLj5T52Hx8W7/YTajtNXGXQf+IksfkcaKGoTkbY=" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.11/vue.min.js" integrity="sha256-ngFW3UnAN0Tnm76mDuu7uUtYEcG3G5H1+zioJw3t+68=" crossorigin="anonymous"></script>
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet">
<script>// Tooltip plugin needs these lowercased globals, oddly enough.
chartist = Chartist; jquery = $;
</script>
<script src="https://cdn.jsdelivr.net/npm/chartist-plugin-tooltip@0.0.11/chartist-plugin-tooltip.js" integrity="sha256-ngO2WQ2lK5livpEUubW2qbfre03s8rHixhMguuXbaAs=" crossorigin="anonymous"></script>
<script src="lib/chartist-plugin-legend.js"></script>
<script src="lib/chartist-logaxis.js"></script>
<script src="lib/chartist-print.js"></script>
<script src="lib/usa_states.js"></script>
<link rel="stylesheet" href="lib/select.css">
<link rel="stylesheet" href="lib/chart.css">
<style>
body { background: #FFF1E3; color: #333;
  font-family: 'Open Sans', sans-serif; font-size: 10pt; }
h1 { font-size: 14pt; }
@media only screen and (max-width:799px) {
  .ct-line { stroke-width: 2px; }
  .ct-point { stroke-width: 5px; }
}
@media only screen and (min-width:800px) {
  .pane-menu { display: inline-block; width: 26%; }
  .pane-chart { display: inline-block; width: 73%; float: right; }
  .ct-line { stroke-width: 3px; }
  .ct-point { stroke-width: 8px; }
}
@media only print {
  .pane-chart { width: 100% }
  body { background: none; }
}
</style>
</head>
<body>
<!--
  User interface, using vue template idioms.
-->
<div id="app" class="pane-menu">
<h1>USA COVID-19 Time Series</h1>
<p>Whole-country stats an top 10 states are shown;
data are pulled directly from
<a href="https://github.com/CSSEGISandData/COVID-19/" >Johns Hopkins CSSE</a>.
<p>
<select v-model="chosen_series" class="select-css">
  <option v-for="option in series_choices" v-bind:value="option">
    {{ option }}
  </option>
</select>
<select v-model="chosen_stat" class="select-css">
  <option v-for="option in stat_choices" v-bind:value="option">
    {{ option }}
  </option>
</select>
<select v-model="chosen_scale" class="select-css">
  <option v-for="option in chosen_stat == 'deltas' ? ['linear'] : scale_choices" v-bind:value="option">
    {{ option }}
  </option>
</select>
&nbsp;
<nobr>start:
<select v-model="chosen_start" class="select-css">
  <option v-for="option in start_choices" v-bind:value="option">
    {{ option }}
  </option>
</select></nobr>
<p>Click on the legend to toggle a series;
hover on points for specific numbers.</p>
</div
><div id="chart" class="pane-chart ct-chart ct-perfect-fourth"></div
><div class="pane-credit">

<p>For policymakers, the chart lets you see USA coronavirus cases in the same way the <a href="https://www.ft.com/coronavirus-latest">Financial Times COVID-19 plot by John Burn-Murdoch</a> compares countries internationally. Select the logarithmic totals with a '>=100' starting threshold, so that "day zero" is the first day there are 100 cases in a state. Over time, if different states' policies have different effects on the growth of the virus, the exponents, and therefore the slopes, will reveal the differences.

<p>For doctors, who must deal with the patients who walk into the ER and who who lie sick in ICU beds, the linear view of day-to-day changes is more appropriate. To see these numbers, switch to the 'delta linear' view in the current month. The spikes show why the panic is justified, and why minor policy changes have massive ramifications.

<p>The graph automatically updates every day based on current data. Please share. And please isolate.

<p>I made this plot to help my physician wife see summaries of US COVID-19 stats that are not being graphed in the press.  It is just one short HTML page (using chartist.js, vue.js, lodash.js), and it should be easy to generalize to international data or other stats.  Pull requests are welcome.

<p>Code is at <a href="https://github.com/davidbau/covid-19-chart"
>https://github.com/davidbau/covid-19-chart</a>.
Open source. (MIT license.)
<address>- <a href="http://davidbau.com/">David Bau</a></address>
</div></body>
<script>
// Globals:
var csse = null, chart = null;

//////////////////////////////////////////////////////////////////////
// Data loading.
// Loads directly from the Johns Hopkins CSSE COVID-19 data feed on
// github. They publish three time series: "Confirmed", "Deaths", and
// "Recovered".  The data in the last category seems inconsistent
// so is not included in the current graph.
//////////////////////////////////////////////////////////////////////
function csv_url(seriesname) {
  var ts_base_url = "https://raw.githubusercontent.com/CSSEGISandData" +
    "/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/";
  return ts_base_url + "time_series_19-covid-" + seriesname + ".csv";
}

function load_csse_data(loaded) {
  var results = {}, pending = 3;
  'Confirmed Deaths Recovered'.split(' ').map(s => {
    Papa.parse(csv_url(s), {
      download: true,
      complete: r => {
        results[s.toLowerCase()] = r.data;
        pending -= 1;
        if (!pending) loaded(results);
      }
    })
  })
}

//////////////////////////////////////////////////////////////////////
// By-day summarization.
// Some days the CSSE data is broken out by-county and other days
// by-state.  This function sums time series across rows based on
// function filters for state and country strings; and get_state_data
// applies a rule for consolidating U.S. state data that is coded
// as either "County Name, ST' or "State Name".
//////////////////////////////////////////////////////////////////////
function rollup_ts(series, state_filter, country_filter) {
  var names = series[0],
    state_i = fieldnum(names, 'state'),
    country_i = fieldnum(names, 'country'),
    ts_i = first_date_field(names),
    ts_names = names.slice(ts_i),
    totals = _.fill(Array(ts_names.length), 0);
  for (var row of series.slice(1)) {
    if (state_filter && !state_filter(row[state_i]) ||
        country_filter &&  !country_filter(row[country_i])) {
      continue;
    }
    for (var i = ts_i; i < names.length; ++i) {
      totals[i - ts_i] += (row[i] == '' ? 0 : parseInt(row[i]));
    }
  }
  return [ts_names, totals];
}

function get_state_data(csse, field, chosen_abbrev, chosen_full) {
  var dates, totals, deltas;
  [dates, totals] = rollup_ts(csse[field],
    state => { return !chosen_abbrev ||
       state.endsWith(chosen_abbrev) ||
       state == chosen_full },
    country => { return /^US$/.exec(country) });
  deltas = series_deltas(totals);
  return { dates: dates, totals: totals, deltas: deltas }
}

//////////////////////////////////////////////////////////////////////
// Start-day shifting.
// To make different time series comparable, we can start them
// all on the same day, or count "day 0" as the day when they
// all pass a fixed threshold.  available_start_rules makes a
// list of first-of-month days, and a subset of >=10, 100, 1000
// rules that apply to the extracted series data; and apply_start_rule
// shifts the extracted data according to a selected rule.
//////////////////////////////////////////////////////////////////////
function available_start_rules(extracted) {
  var dates = extracted.labels;
  var data_series = extracted.series;
  var first_d = dates[0];
  var other_d = dates.slice(1).filter(x => !!/^\d+\/1\/\d+$/.exec(x));
  var third_v = _.sortBy(data_series.map(
      x => _.max(x[1].map(x => x.value)), x => -x))[2];
  var gt_rules = [10, 100, 1000].filter(x => (x < third_v)).map(x => '>=' + x);
  return _.concat([first_d], other_d, gt_rules);
}
function apply_start_rule(start, extracted) {
  var labels = extracted.labels;
  var data_series = extracted.series;
  if (start.startsWith('>=')) {
    var min_v = parseInt(start.slice(2));
    function shift_series(s, min) {
      var first_i = _.findIndex(s, x => x !== null && x.value >= min);
      if (first_i >= 0) {
        return s.slice(first_i);
      } else {
        return null;
      }
    }
    data_series = data_series.map(x => [x[0], shift_series(x[1], min_v)]);
    data_series = data_series.filter(x => !!x[1]);
    labels = _.range(0, _.max(data_series.map(x => x[1].length)));
    return {labels: labels, series: data_series};
  }
  if (parse_date(start)) {
    var first_i = labels.indexOf(start);
    if (first_i >= 0) {
      labels = labels.slice(first_i);
      data_series = data_series.map(x => [x[0], x[1].slice(first_i)]);
    }
    return {labels: labels, series: data_series};
  }
  return {labels: labels, series: data_series};
}

//////////////////////////////////////////////////////////////////////
// Data extraction.
// Loaded data is summed, selected, filtered, and sorted here.
// The user can choose a field (deaths/confirmed), a stat
// (totals/detlas) and a scale (linear/log) (on a log scale,
// nonpositive numbers are filtered out).  extract_data will
// return an "extract" object which has a list of (date) labels
// and a series which is a list of pairs ['ST', [day1, day2,...]]
// of time series data, by state abbreviation.  Ten states
// are included, based on the highest numbers on the last day.
//////////////////////////////////////////////////////////////////////
function extract_data(csse, field, stat, scale) {
  field = field || 'confirmed';
  stat = stat || 'totals';
  scale = scale || 'log10';
  var national_data = get_state_data(csse, field, null);
  var first_nz = _.findIndex(national_data.totals, i => i > 0);
  var national_series = national_data[stat].slice(first_nz);
  var dates = national_data.dates.slice(first_nz);
  var state_series = _.transform(USA_STATES, (r, v, k) => {
    r[k] = get_state_data(csse, field, k, v)[stat].slice(first_nz);
    if (/log/.exec(scale)) {
      r[k] = r[k].map(x => x > 0 ? x : null)
    }
  });
  function avg_last3(s) {
    return _.sum(s.slice(-3)) / (1e-10 + s.slice(-3).length);
  }
  var top_states = _.toPairs(state_series)
      .sort((x, y) => (avg_last3(y[1]) || 0) - (avg_last3(x[1]) || 0)
           ).slice(0, 10);
  var series = _.concat([['US', national_series]], top_states);
  var desc_series = series.map(p => [p[0], p[1].map((x, i) =>
     { return { meta: p[0] + ' ' + dates[i], value: x }; })]);
  return {
    labels: dates,
    series: desc_series
  };
}

//////////////////////////////////////////////////////////////////////
// Plotting.
// The extract data is plotted using chartist.js,
// using the given scale.
//////////////////////////////////////////////////////////////////////
function plot_series(extract, scale) {
  scale = scale || 'log10';
  if (chart) { chart.detach(); }
  chart = new Chartist.Line('#chart', {
    labels: extract.labels.map(x => {
      if (!x) return x;
      x = '' + x;
      return x.replace(/(\d+)\/(\d+)\/20$/, '$1/\n$2');
    }),
    series: extract.series.map(x => x[1]),
  }, {
    lineSmooth: Chartist.Interpolation.none({
      fillHoles: false
    }),
    classNames: {
      gridMinor: 'ct-grid-minor'
    },
    axisX: {
      labelInterpolationFnc: function skipLabels(value, index) {
        return index % 7  === (parse_date(extract.labels[0]) ?
            (extract.labels.length - 1) % 7 : 0) ? value : null;
      },
    },
    axisY: {
      showMinorGrid: true,
      type: Chartist.AutoScaleAxis,
      scale: scale,
    },
    chartPadding: {
      top: 50,
      bottom: 10,
      left: 20,
      right: 10,
    },
    plugins: [
      Chartist.plugins.legend({
        legendNames: extract.series.map(x => x[0])
      }),
      Chartist.plugins.tooltip()
    ]
  });
  preparePrintChart(chart);
  return chart;
}

//////////////////////////////////////////////////////////////////////
// Selection.
// The vue.js app is used to manage the user's selection of different
// options.
//////////////////////////////////////////////////////////////////////
var theapp = new Vue({
  el: '#app',
  data: {
    csse: null,
    series_choices: ['confirmed', 'deaths'], // 'recovered' seems incomplete.
    stat_choices: ['totals', 'deltas'],
    scale_choices: ['linear', 'log10'],
    chosen_series: 'confirmed',
    chosen_stat: 'totals',
    chosen_scale: 'log10',
    chosen_start: '>=100',
  },
  computed: {
    start_choices: function() {
      if (this.csse == null) { return ['']; }
      var extract = extract_data(
          this.csse, this.chosen_series, this.chosen_stat, this.chosen_scale);
      return available_start_rules(extract);
    }
  },
  watch: {
    chosen_series: function(val) { this.draw_chart(); },
    chosen_stat: function(val) {
      if (val == 'deltas' && this.chosen_scale == 'log10') {
        this.chosen_scale = 'linear';
      }
      this.draw_chart();
    },
    chosen_scale: function(val) { this.draw_chart(); },
    chosen_start: function(val) { this.draw_chart(); },
  },
  methods: {
    draw_chart: function() {
      if (this.start_choices.indexOf(this.chosen_start) < 0) {
        this.chosen_start = this.start_choices[0];
      }
      var extract = extract_data(
          this.csse, this.chosen_series, this.chosen_stat, this.chosen_scale);
      var shifted_extract = apply_start_rule(this.chosen_start, extract);
      plot_series(shifted_extract, this.chosen_scale);
    }
  }
});

//////////////////////////////////////////////////////////////////////
// Utility functions.
//////////////////////////////////////////////////////////////////////
function series_deltas(series) {
  var deltas = _.fill(Array(series.length), 0);
  deltas[0] = series[0];
  for (var i = 1; i < series.length; ++i) {
    deltas[i] = series[i] - series[i - 1];
  }
  return deltas;
}
function parse_date(name) {
  return /^(\d{1,2})\/(\d{1,2})\/(\d{2})$/.exec(name);
}
function fieldnum(names, pat) {
  return names.findIndex(n => RegExp(pat, 'i').exec(n))
}
function first_date_field(names) {
  return names.findIndex(n => !!parse_date(n));
}

//////////////////////////////////////////////////////////////////////
// Initialization.
// Load the csse data, and then tell the vue app to draw the chart.
//////////////////////////////////////////////////////////////////////
load_csse_data((d) => {
  csse = d;
  theapp.csse = d;
  theapp.draw_chart();
});

</script>
